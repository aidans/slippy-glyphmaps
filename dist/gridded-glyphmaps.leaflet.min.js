import*as t from"leaflet";import*as e from"d3";const o=(t.Layer?t.Layer:t.Class).extend({initialize:function(e){this._map=null,this._canvas=null,this._frame=null,this._delegate=null,t.setOptions(this,e)},delegate:function(t){return this._delegate=t,this},needRedraw:function(){return this._frame||(this._frame=t.Util.requestAnimFrame(this.drawLayer,this)),this},_onLayerDidResize:function(t){this._canvas.width=t.newSize.x,this._canvas.height=t.newSize.y},_updatePosition:function(){t.DomUtil.setPosition(this._canvas,[0,0])},_onLayerDidMove:function(){this._updatePosition(),this.drawLayer()},getEvents:function(){var e={resize:this._onLayerDidResize,moveend:this._onLayerDidMove,zoom:this._onLayerDidMove};return this._map.options.zoomAnimation&&t.Browser.any3d&&(e.zoomanim=this._animateZoom),e},onAdd:function(e){this._map=e,this._canvas=t.DomUtil.create("canvas","leaflet-layer"),this.tiles={};var o=this._map.getSize();this._canvas.width=o.x,this._canvas.height=o.y;var n=this._map.options.zoomAnimation&&t.Browser.any3d;t.DomUtil.addClass(this._canvas,"leaflet-zoom-"+(n?"animated":"hide")),e.getPanes().overlayPane.appendChild(this._canvas),e.on(this.getEvents(),this);var i=this._delegate||this;i.onLayerDidMount&&i.onLayerDidMount(),this._updatePosition(),this.needRedraw()},onRemove:function(e){var o=this._delegate||this;o.onLayerWillUnmount&&o.onLayerWillUnmount(),this._frame&&t.Util.cancelAnimFrame(this._frame),e.getPanes().overlayPane.removeChild(this._canvas),e.off(this.getEvents(),this),this._canvas=null},addTo:function(t){return t.addLayer(this),this},LatLonToMercator:function(t){return{x:6378137*t.lng*Math.PI/180,y:6378137*Math.log(Math.tan((90+t.lat)*Math.PI/360))}},drawLayer:function(){var t=this._map.getSize(),e=this._map.getBounds(),o=this._map.getZoom(),n=this.LatLonToMercator(this._map.getCenter()),i=this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize())),s=this._delegate||this;s.onDrawLayer&&s.onDrawLayer({layer:this,canvas:this._canvas,bounds:e,size:t,zoom:o,center:n,corner:i}),this._frame=null},_animateZoom:function(e){var o=this._map.getZoomScale(e.zoom),n=t.Layer?this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(),e.zoom,e.center).min:this._map._getCenterOffset(e.center)._multiplyBy(-o).subtract(this._map._getMapPanePos());t.DomUtil.setTransform(this._canvas,n,o)}}),n=function(t){return{getColRow:(e,o)=>[Math.trunc(e/t),Math.trunc(o/t)],getXYCentre:(e,o)=>[e*t+t/2,o*t+t/2],getBoundary:(e,o,n)=>{const i=n?t-2*n:t,s=[e*t+t/2,o*t+t/2];return[[s[0]-i/2,s[1]-i/2],[s[0]+i/2,s[1]-i/2],[s[0]+i/2,s[1]+i/2],[s[0]-i/2,s[1]+i/2]]},getBoundaryScreenCoord:(e,o,n)=>{const i=n?t-2*n:t,s=[e,o];return[[s[0]-i/2,s[1]-i/2],[s[0]+i/2,s[1]-i/2],[s[0]+i/2,s[1]+i/2],[s[0]-i/2,s[1]+i/2]]},getCellSize:()=>t,type:"grid"}},i=function(t){function e(t){const e={NEIGHBORS_DI:[0,1,1,0,-1,-1],NEIGHBORS_DJ:[[-1,-1,0,1,0,-1],[-1,0,1,1,1,0]],NUM_NEIGHBORS:6};e.RADIUS=Math.trunc(1.3*t/2),e.WIDTH=2*e.RADIUS,e.HEIGHT=Math.trunc(e.RADIUS*Math.sqrt(3)),e.SIDE=3*e.RADIUS/2;let o=[e.RADIUS/2,e.SIDE,e.WIDTH,e.SIDE,e.RADIUS/2,0];e.CORNERS_DX=o;let n=[0,0,e.HEIGHT/2,e.HEIGHT,e.HEIGHT,e.HEIGHT/2];return e.CORNERS_DY=n,e}const o=e(t);let n,i;return{getColRow:(t,e)=>{let n=Math.floor(t/o.SIDE),i=t-o.SIDE*n,s=e-n%2*o.HEIGHT/2,a=Math.floor(s/o.HEIGHT),r=s-o.HEIGHT*a;return i>Math.abs(o.RADIUS/2-o.RADIUS*r/o.HEIGHT)?[n,a]:[n-1,a+n%2-(r<o.HEIGHT/2?1:0)]},getXYCentre:(t,e)=>{let n=[t*o.SIDE,o.HEIGHT*(2*e+t%2)/2];return[n[0]+o.RADIUS,n[1]+o.HEIGHT/2]},getXYCentreCellUnits:(t,e)=>{const o=Math.sqrt(3);let n=[1.5*t,o*(2*e+t%2)/2];return[n[0]+1,n[1]+o/2]},getBoundary:(s,a,r)=>{let l=[];r||(r=0),r>0&&r!=n&&(n=r,i=e(t-2*r));const h=r?i:o;let c=[s*o.SIDE,o.HEIGHT*(2*a+s%2)/2];for(let t=0;t<h.NUM_NEIGHBORS;t++)l.push([Math.round(c[0]+2*r/3*2+h.CORNERS_DX[t]),Math.round(c[1]+2*r/3*2+h.CORNERS_DY[t])]);return l},getCellSize:()=>t,type:"hex"}},s=function(t){const e=t.data,o=t.width,n=t.height,i=t.cellSize,s=t.getLocationFn,a=t.coordToScreenFn,r=t.screenToCoordFn,l=t.preAggrFn,h=t.aggrFn,c=t.postAggrFn,g=t.offSetCoordRef,p=t.discretisationMode,u=t.reduceMaup,d=t.panel,f=t.discretiser,y=t.global,m=t.offSetMaupMode;let F=[];"relativeToMouse"==p?(F.xOffset=Math.trunc(a(g)[0]%i),F.yOffset=Math.trunc(a(g)[1]%i)):(F.xOffset=0,F.yOffset=0),F.type=f.type,F.cellSize=i,r([0,n]),r([o,0]),l&&l(F.flat(),i,y,d);for(let t of e){const e=[],o=s(t);if(o.type){const t=turf.bbox(o),n=a([t[0],t[1]]),s=a([t[2],t[3]]);for(let t=Math.trunc(n[0]/i);t<s[0]/i;t++)for(let o=Math.trunc(n[1]/i);o<s[1]/i;o++)e.push([t,o]);if(0==e.length){const t=turf.centroid(o);e.push([Math.trunc(t[0]/i),Math.trunc(t[1]/i)])}}else{const t=a(o);if(u){console.log("mauping");const o=f.getColRow(t[0]-F.xOffset,t[1]-F.yOffset),n=t[0]-F.xOffset-o[0]*i,s=t[1]-F.yOffset-o[1]*i;let a=n/i;a<.5?a=-(.5-a):a-=.5;let r=s/i;r<.5?r=-(.5-r):r-=.5,e.push([o[0],o[1],1-(Math.abs(a)+Math.abs(r))/2]),e.push([o[0]+(a<0?-1:1),o[1]+(r<0?-1:1),(Math.abs(a)+Math.abs(r))/2]),e.push([o[0]+(a<0?-1:1),o[1],Math.abs(a)]),e.push([o[0],o[1]+(r<0?-1:1),Math.abs(r)])}else{if(m)for(let o=0;o<i;o+=3)for(let n=0;n<i;n+=3)e.push([...f.getColRow(t[0]+(o-i/2)-F.xOffset,t[1]+(o-i/2)-F.yOffset),n*i+o]);e.push(f.getColRow(t[0]-F.xOffset,t[1]-F.yOffset))}}for(const o of e){if(F[o[0]]||(F[o[0]]=[]),!F[o[0]][o[1]]){const t=o[0],e=o[1];F[t][e]={col:t,row:e,getBoundary:o=>f.getBoundary(t,e,o),getXCentre:()=>f.getXYCentre(t,e)[0]+F.xOffset,getYCentre:()=>f.getXYCentre(t,e)[1]+F.yOffset,getCellSize:()=>i}}if(h)if(Array.isArray(h))for(const e of h)e&&e(F[o[0]][o[1]],t,o[2]?o[2]:1,y,d);else m?h(F[o[0]][o[1]],{...t,maupMode:o[2]},1,y,d):h(F[o[0]][o[1]],t,o[2]?o[2]:1,y,d)}}return c&&c(F.flat(),i,y,d),F};function a(t){const e=t.grid,o=t.properties,n=t.propertyTypes;if(void 0===o||void 0===n)return void console.log("Need to define properties and propertyTypes for smoothing");const i=t.discretiser,s=t.kernelRadius,a=e.length+s,r=Math.max(...Object.values(e.map((t=>t.length))))+s;{const t=[];for(let o=-s;o<s;o++)for(let n=-s;n<s;n++){let a;if("grid"==e.type)a=Math.sqrt(Math.pow(o,2)+Math.pow(n,2));else if("hex"==e.type){const[t,e]=i.getXYCentreCellUnits(0,0),[s,r]=i.getXYCentreCellUnits(o,o<0?n:-n);a=Math.sqrt(Math.pow(t-s,2)+Math.pow(e-r,2))}if(a<s){var l=(s-a)/(s+a);t[o]||(t[o]=[]),t[o][n]=l}}for(let l=0;l<o.length;l++)for(let g=0;g<a;g++)for(let p=0;p<r;p++){let u,d=0;for(var h=-s;h<=s;h++)for(var c=-s;c<=s;c++)if(g+h>=0&&g+h<a&&p+c>=0&&p+c<r)if("value"===n[l]){let n,i=e[g+h]&&e[g+h][p+c]?e[g+h][p+c][o[l]]:0;isNaN(i)&&(i=0),n="hex"!=e.type||g%2!=0||h%2!=1&&h%2!=-1?t[h]?t[h][c]:0:t[h]?t[h][c+1]:0,n>0&&(u=u?u+i*n:i*n,d=d?d+n:n)}else if("array"===n[l]){let n,i=e[g+h]&&e[g+h][p+c]&&e[g+h][p+c][o[l]]?e[g+h][p+c][o[l]]:[];if(n="hex"!=e.type||g%2!=0||h%2!=1&&h%2!=-1?t[h]?t[h][c]:0:t[h]?t[h][c+1]:0,n>0){d=d?d+n:n;for(let t=0;t<i.length;t++){let e=i[t];e||(e=0),isNaN(e)&&(e=0),u||(u=[]),u[t]=void 0!==u[t]&&u[t]?u[t]+e*n:e*n}}}e[g]||(e[g]=[]);for(let t=0;t<o.length;t++)if("value"===n[t])u/d>0&&(e[g][p]||(e[g][p]={getBoundary:()=>i.getBoundary(g,p),getXCentre:()=>i.getXYCentre(g,p)[0]+e.xOffset,getYCentre:()=>i.getXYCentre(g,p)[1]+e.yOffset,getCellSize:()=>i.getCellSize(),new:!0}),e[g][p]["_"+o[t]]=u/d);else if("array"===n[t]&&u)for(let n=0;n<u.length;n++)u[n]/d>0&&(e[g][p]||(e[g][p]={getBoundary:()=>i.getBoundary(g,p),getXCentre:()=>i.getXYCentre(g,p)[0]+e.xOffset,getYCentre:()=>i.getXYCentre(g,p)[1]+e.yOffset,getCellSize:()=>i.getCellSize(),new:!0}),e[g][p]["_"+o[t]]||(e[g][p]["_"+o[t]]=[]),e[g][p]["_"+o[t]][n]=u[n]/d)}for(let t of e.flat())for(let e=0;e<o.length;e++)void 0!==t["_"+o[e]]&&(t[o[e]]=t["_"+o[e]])}}function r(t){const o=t.grid,n=t.discretiser,i=t.properties,s=t.propertyTypes;if(void 0===i||void 0===s)return void console.log("Need to define properties and propertyTypes for smoothing");const a=t.kernelRadius,r=o.length+a,l=Math.max(...Object.values(o.map((t=>t.length))))+a;for(let t=0;t<i.length;t++)if("value"===s[t]){const s=[];for(let e=0;e<l;e++)for(let n=0;n<r;n++)s.push(o[n]&&o[n][e]&&o[n][e][i[t]]?o[n][e][i[t]]:0);e.blur2({data:s,width:r,height:l},a);for(let e=0;e<r;e++)for(let a=0;a<l;a++){const l=s[e+a*r];l>0?(o[e]||(o[e]=[]),o[e][a]||(o[e][a]={getBoundary:()=>n.getBoundary(e,a),getXCentre:()=>n.getXYCentre(e,a)[0]+o.xOffset,getYCentre:()=>n.getXYCentre(e,a)[1]+o.yOffset,getCellSize:()=>n.getCellSize(),new:!0}),o[e][a][i[t]]=l):o[e]&&o[e][a]&&o[e][a][i[t]]&&(o[e][a][i[t]]=l)}}return o}const l=o.extend({initialize:function(t){o.prototype.initialize.call(this,t),this.options.cellSize=this.options.cellSize?this.options.cellSize:5,this.options.discretisationShape=this.options.discretisationShape?this.options.discretisationShape:"grid",this.options.getLocationFn=this.options.getLocationFn?this.options.getLocationFn:t=>[t.lon,t.lat],this.options.discretiserFn=this.options.discretiserFn?this.options.discretiserFn:s,this.global={},this.grid=[],this._setupAggregationFunctions()},onAdd:function(t){console.log("[Glyph Layer] onAdd called with map:",t),o.prototype.onAdd.call(this,t),this.options.glyph?.initFn&&(console.log("[Glyph Layer] Calling initFn"),this.options.glyph.initFn([],this.options.cellSize,this.global,this)),console.log("[Glyph Layer] Calling needRedraw"),this.needRedraw()},_setupAggregationFunctions:function(){const{type:t,colourFieldFn:e,glyph:o}=this.options;o?(this.options.aggrFn=o.aggrFn,this.options.postAggrFn=o.postAggrFn,this.options.preAggrFn=o.preAggrFn,this.options.preDrawFn=o.preDrawFn,this.options.drawFn=o.drawFn,this.options.postDrawFn=o.postDrawFn,this.options.initFn=o.initFn,this.options.tooltipTextFn=o.tooltipTextFn):"count"===t?this.options.aggrFn=(t,e,o)=>t.value=(t.value??0)+o:"sum"===t?this.options.aggrFn=(t,o,n)=>t.value=(t.value??0)+e(o)*n:"mean"===t&&(this.options.aggrFn=(t,o,n)=>{t.sum=(t.sum??0)+e(o)*n,t.count=(t.count??0)+1},this.options.postAggrFn=t=>{for(const e of t.flat())e&&e.count>0&&(e.value=e.sum/e.count)})},onDrawLayer:function(e){console.log("[Glyph Layer] onDrawLayer called. Zoom:",e.zoom),console.log("[Glyph Layer] Canvas size:",e.size),console.log("[Glyph Layer] Map bounds:",this._map.getBounds()),console.log("[Glyph Layer] Map center:",this._map.getCenter()),console.log("[Glyph Layer] Map zoom:",this._map.getZoom());const o=e.canvas.getContext("2d");o.clearRect(0,0,e.canvas.width,e.canvas.height);let{cellSize:s,discretisationShape:l,kernelBW:h,reduceMaup:c,data:g}=this.options;this.discretiser&&this._previousCellSize===s||("grid"===l?this.discretiser=n(s):"hex"===l&&(this.discretiser=i(s))),this.global.discretiser=this.discretiser,this.options.glyph?.initFn&&this.options.glyph.initFn([],s,this.global,this);const p=o=>{const n=t.latLng(o[1],o[0]),i=this._map.latLngToContainerPoint(n),s=[i.x,i.y];return console.log(`[coordToScreenFn] Input: [${o[0]}, ${o[1]}], Output: [${s[0]}, ${s[1]}]`),(s[0]<0||s[0]>e.size.x||s[1]<0||s[1]>e.size.y)&&console.warn(`[coordToScreenFn] Coordinate [${s[0]}, ${s[1]}] is outside canvas bounds [0, 0, ${e.size.x}, ${e.size.y}]`),s};this.grid=this.options.discretiserFn({data:g,width:e.size.x,height:e.size.y,getLocationFn:this.options.getLocationFn,coordToScreenFn:p,screenToCoordFn:e=>{const o=t.point(e[0],e[1]),n=this._map.containerPointToLatLng(o);return[n.lng,n.lat]},cellSize:s,discretiser:this.discretiser,aggrFn:this.options.aggrFn,postAggrFn:this.options.postAggrFn,global:this.global,panel:this}),console.log("[Glyph Layer] Grid generated:",this.grid),console.log("[Glyph Layer] Grid dimensions:",this.grid.length,"x",this.grid[0]?this.grid[0].length:0);const u=this.grid.flat().filter((t=>t));if(console.log(`[Glyph Layer] Grid generated. Found ${u.length} populated cells.`),u.length>0){const t=u[0];console.log("[Glyph Layer] Sample cell:",t),console.log("[Glyph Layer] Sample cell has ts:",!!t.ts),t.ts&&console.log("[Glyph Layer] Sample cell ts length:",t.ts.length)}else if(console.log("[Glyph Layer] No populated cells found. Checking coordinate transformation..."),g.length>0){const o=g[0],n=this.options.getLocationFn(o),i=p(n);console.log("[Glyph Layer] Sample data location:",n),console.log("[Glyph Layer] Sample screen coord:",i),console.log("[Glyph Layer] Canvas size:",e.size);const s=this._map.getBounds();console.log("[Glyph Layer] Map bounds:",s),console.log("[Glyph Layer] Sample location within bounds:",s.contains(t.latLng(n[1],n[0])));const a=t.latLng(n[1],n[0]),r=this._map.latLngToContainerPoint(a);console.log("[Glyph Layer] Direct transformation:",r),console.log("[Glyph Layer] Screen coord from function:",i)}if(this._previousCellSize=s,h&&h>0){(this.options.useBlur?r:a)({grid:this.grid,properties:this.options.glyph?.kernelSmoothProperties,propertyTypes:this.options.glyph?.kernelSmoothPropertyTypes,discretiser:this.discretiser,kernelRadius:this.options.useBlur?Math.trunc(h/2):h})}if(this.options.glyph?.preDrawFn&&(o.save(),this.options.glyph.preDrawFn(this.grid.flat(),s,o,this.global,this),o.restore()),this.options.glyph?.drawFn){console.log("[Glyph Layer] Executing custom drawFn."),o.save();const t=Array.isArray(this.options.glyph.drawFn)?this.options.glyph.drawFn:[this.options.glyph.drawFn];for(const e of t)for(const t of this.grid.flat())t&&e(t,t.getXCentre(),t.getYCentre(),s,o,this.global,this);o.restore()}this.options.glyph?.postDrawFn&&(o.save(),this.options.glyph.postDrawFn(this.grid.flat(),s,o,this.global,this),o.restore())},setData:function(t){this.options.data=t,this.needRedraw()},setOptions:function(e){t.Util.setOptions(this,e),this._setupAggregationFunctions(),this.needRedraw()}}),h=function(t){const o=t.numBins,n=t.context,i=t.minV,s=t.maxV,a=t.values,r=t.x,l=t.y,h=t.width,c=t.height,g=t.colourScale,p=Array(o+2).fill(0),u=(s-i)/p.length;for(const t of a)if(t){const e=Math.trunc((t-i)/u)+1;e<1?p[0]++:e>p.length-2?p[p.length-1]++:p[e]++}const d=Math.max(...p.slice(1,-2)),f=e.scaleLinear().domain([0,d]).range([0,c-30]),y=h/p.length;n.fillStyle="#fff8",n.fillRect(r,l,h,c);for(let t=0;t<p.length;t++)n.fillStyle=g(t/p.length),n.fillRect(r+t*y,l+c-10,y,-10),0==t?n.fillStyle=g(0):t==p.length-1?n.fillStyle=g(1):n.fillStyle=g(.5),n.fillRect(r+t*y,l+c-20,y,-Math.min(f(p[t]),c-20));n.fillStyle="#000",n.font="sans-serif 8pt",n.textBaseline="bottom",n.textAlign="left",n.fillText(i.toLocaleString(void 0,{minimumFractionDigits:0,maximumFractionDigits:3}),r+y,l+c),n.textAlign="right",n.fillText(s.toLocaleString(void 0,{minimumFractionDigits:0,maximumFractionDigits:3}),r+h-y,l+c)},c=t=>{const e=t.name,o=t.decKey,n=t.incKey,i=t.resetKey;t.incDecType;const s=t.decFn?t.decFn:t=>t-1,a=t.incFn?t.incFn:t=>t+1,r=t.numberFormatFn?t.numberFormatFn:t=>+t.toFixed(),l=t.resetFn,h=t.resetType?t.resetType:"preDraw";let c=void 0!==t.autoscale&&t.autoscale;const g=t.onChangeFn,p=(t,o)=>{null!=t[e]&&(t[e]=a(t[e])),g&&g(t),o.redraw()},u=(t,o)=>{null!=t[e]&&(t[e]=s(t[e])),g&&g(t),o.redraw()},d=(t,o)=>{t[e]=void 0,g&&g(t),o.redraw()},f=()=>c;return{...t,initFn:(t,e,s,a)=>{a.addEventListener("keydown",(t=>{(o&&o.startsWith("SHIFT_")===t.shiftKey&&(o.endsWith("LEFT")&&37==t.keyCode||o.endsWith("RIGHT")&&39==t.keyCode)||t.key===o)&&(t.preventDefault(),u(s,a)),(n&&n.startsWith("SHIFT_")===t.shiftKey&&(n.endsWith("LEFT")&&37==t.keyCode||n.endsWith("RIGHT")&&39==t.keyCode)||t.key===n)&&(t.preventDefault(),p(s,a)),i&&t.key==i&&(t.preventDefault(),d(s,a))}))},toggleAutoscale:()=>{c=!c},getAutoscale:f,preAggrFn:"preAggr"==h?(t,o,n,i,s)=>{l&&(f()||void 0===i[e])&&(i[e]=l(t.flat(),o,s))}:void 0,preDrawFn:"preDraw"==h?(t,o,n,i,s)=>{l&&(f()||void 0===i[e])&&(i[e]=l(t.flat(),o,s))}:void 0,doInc:p,doDec:u,doReset:d,numberFormatFn:r}};function g(t,e,o,n){const i=e.getBoundary(n);t.fillStyle=o,t.beginPath(),t.moveTo(i[0][0],i[0][1]);for(let e=1;e<i.length;e++)t.lineTo(i[e][0],i[e][1]);t.closePath(),t.fill()}const p=t=>{t||(t={});const o=t.colourScheme?t.colourScheme:e.scaleSequential(e.interpolateOranges),n=void 0===t.colourAutoscale||t.colourAutoscale,i=t.valueFn,s=t.normaliseValueFn,a=t.weightValueFn,r=t.type,l=void 0===t.useTransparency||t.useTransparency,g=void 0===t.showLegend||t.showLegend,p=t.numberFormatFn,u=t.initFn,d=t.preDrawFn,f=t.postDrawFn,y=t.aggrFn,m=t.postAggrFn,F=t.tooltipTextFn;return{scaleParams:[c({name:"colourMaxV",decKey:"LEFT",decFn:t=>t-t/10,incKey:"RIGHT",incFn:t=>t+t/10,resetKey:"s",autoscale:n,resetFn:(t,o,n)=>e.quantile(t.map((t=>t&&t.value?t.value:0)),.99)})],initFn:(t,e,o,n)=>{u&&u(t,e,o,n)},kernelSmoothProperties:["value"],kernelSmoothPropertyTypes:["value"],preAggrFn:t=>{},aggrFn:(t,e,o,n,l)=>{let h;if("count"!=r&&(h=i(e,n)??0*o??0),"mean"==r)t.value=t.value?t.value+(h||0):h,t.count=t.count?t.count+o:o;else if("sum"==r)t.value=t.value?t.value+(h||0):h,t.count=t.count?t.count+o:o;else if("weightedMean"==r){const n=a(e)*o??0;t.value=t.value?t.value+h*n:h*n,t.totalWeight=t.totalWeight?t.totalWeight+n:n}else"count"==r&&(t.value=t.count?t.count+o:o,t.count=t.value);if(t.count=t.count?t.count+o:o,s){const o=s(e)??0;t.denominator=t.denominator?t.denominator+o:o}y&&y(t,e,o,n,l)},postAggrFn:(t,e,o,n)=>{if("mean"==r)for(const e of t)e&&e.count&&(e.value=e.value/e.count);if("weightedMean"==r)for(const e of t)e&&e.count&&(e.value=e.value/e.totalWeight);if(s)for(const e of t)e.value=e.value/e.denominator??0;m&&m(t,e,o,n)},preDrawFn:(t,o,n,i,s)=>{d&&d(t,o,n,i,s),i.colourScale=e.scaleLinear().domain([0,i.colourMaxV]).range([0,1]).clamp(!0)},drawFn:(t,e,n,i,s,a,r)=>{if(t&&t.value){const e=t.getBoundary();s.fillStyle=o(a.colourScale(t.value)),l&&(s.globalAlpha=a.colourScale(t.value)),s.beginPath(),s.moveTo(e[0][0],e[0][1]);for(let t=1;t<e.length;t++)s.lineTo(e[t][0],e[t][1]);s.closePath(),s.fill()}},postDrawFn:(t,e,n,i,s)=>{g&&i.colourMaxV&&(h({context:n,values:t.map((t=>t?t.value:NaN)),minV:0,maxV:i.colourMaxV,numBins:20,x:s.getWidth()-160,y:s.getHeight()-60,width:150,height:50,colourScale:o}),f&&f(t,e,n,i,s))},tooltipTextFn:t=>F?F(t):void 0!==t.value?p?p(t.value):t.value:""}},u=function(t){const e=t&&t.valueFn?t.valueFn:void 0,o=t&&t.glyphLocationFn?t.glyphLocationFn:void 0,i=t&&t.boundaryFn?t.boundaryFn:void 0;return function(t){const s=t.data,a=t.width,r=t.height,l=t.cellSize,h=t.getLocationFn,c=t.coordToScreenFn,g=t.screenToCoordFn,p=t.preAggrFn,u=t.aggrFn,d=t.postAggrFn,f=t.panel,y=n(l),m=t.global;let F={};const v=g([0,r]),S=g([a,0]);p&&p([],l,m,f);let _=0;for(let t of s){let n;e?n=e(t):(n=_,_++);const s=o?o(n)??[0,0]:h(t),a=c(s);if(s[0]>=v[0]&&s[0]<=S[0]&&s[1]>=v[1]&&s[1]<=S[1]){let e=F[n];if(!e){let t;i&&(t=i(n)?.map((t=>c([t[0],t[1]])))),e={getBoundary:t?()=>t:t=>y.getBoundaryScreenCoord(a[0],a[1],t),getXCentre:()=>Math.trunc(a[0]),getYCentre:()=>Math.trunc(a[1]),getCellSize:()=>l},F[n]=e}if(u)if(Array.isArray(u))for(const o of u)o&&o(e,t,1,m,f);else u(e,t,1,m,f)}}const L=Object.values(F);return L.yOffset=0,L.xOffset=0,d&&d(L,l,m,f),L}};export{l as GriddedGlyphLayer,r as _blur,g as _drawCellBackground,h as _drawLegend,s as _generate2DHeatMap,n as _getGridDiscretiser,i as _getHexDiscretiser,a as _kernelSmooth,c as _setupParamFns,u as createDiscretiserValue,p as heatmapGlyph};
