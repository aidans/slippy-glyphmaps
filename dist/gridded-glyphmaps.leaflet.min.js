import*as t from"leaflet";import*as e from"d3";const o=(t.Layer?t.Layer:t.Class).extend({initialize:function(e){this._map=null,this._canvas=null,this._frame=null,this._delegate=null,t.setOptions(this,e)},delegate:function(t){return this._delegate=t,this},needRedraw:function(){return this._frame||(this._frame=t.Util.requestAnimFrame(this.drawLayer,this)),this},_onLayerDidResize:function(t){this._canvas.width=t.newSize.x,this._canvas.height=t.newSize.y},_updatePosition:function(){t.DomUtil.setPosition(this._canvas,[0,0])},_onLayerDidMove:function(){this._updatePosition(),this.drawLayer()},getEvents:function(){var e={resize:this._onLayerDidResize,moveend:this._onLayerDidMove,zoom:this._onLayerDidMove};return this._map.options.zoomAnimation&&t.Browser.any3d&&(e.zoomanim=this._animateZoom),e},onAdd:function(e){this._map=e,this._canvas=t.DomUtil.create("canvas","leaflet-layer"),this.tiles={};var o=this._map.getSize();this._canvas.width=o.x,this._canvas.height=o.y;var i=this._map.options.zoomAnimation&&t.Browser.any3d;t.DomUtil.addClass(this._canvas,"leaflet-zoom-"+(i?"animated":"hide")),e.getPanes().overlayPane.appendChild(this._canvas),e.on(this.getEvents(),this);var n=this._delegate||this;n.onLayerDidMount&&n.onLayerDidMount(),this._updatePosition(),this.needRedraw()},onRemove:function(e){var o=this._delegate||this;o.onLayerWillUnmount&&o.onLayerWillUnmount(),this._frame&&t.Util.cancelAnimFrame(this._frame),e.getPanes().overlayPane.removeChild(this._canvas),e.off(this.getEvents(),this),this._canvas=null},addTo:function(t){return t.addLayer(this),this},LatLonToMercator:function(t){return{x:6378137*t.lng*Math.PI/180,y:6378137*Math.log(Math.tan((90+t.lat)*Math.PI/360))}},drawLayer:function(){var t=this._map.getSize(),e=this._map.getBounds(),o=this._map.getZoom(),i=this.LatLonToMercator(this._map.getCenter()),n=this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize())),s=this._delegate||this;s.onDrawLayer&&s.onDrawLayer({layer:this,canvas:this._canvas,bounds:e,size:t,zoom:o,center:i,corner:n}),this._frame=null},_animateZoom:function(e){var o=this._map.getZoomScale(e.zoom),i=t.Layer?this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(),e.zoom,e.center).min:this._map._getCenterOffset(e.center)._multiplyBy(-o).subtract(this._map._getMapPanePos());t.DomUtil.setTransform(this._canvas,i,o)}}),i=function(t){return{getColRow:(e,o)=>[Math.trunc(e/t),Math.trunc(o/t)],getXYCentre:(e,o)=>[e*t+t/2,o*t+t/2],getBoundary:(e,o,i)=>{const n=i?t-2*i:t,s=[e*t+t/2,o*t+t/2];return[[s[0]-n/2,s[1]-n/2],[s[0]+n/2,s[1]-n/2],[s[0]+n/2,s[1]+n/2],[s[0]-n/2,s[1]+n/2]]},getBoundaryScreenCoord:(e,o,i)=>{const n=i?t-2*i:t,s=[e,o];return[[s[0]-n/2,s[1]-n/2],[s[0]+n/2,s[1]-n/2],[s[0]+n/2,s[1]+n/2],[s[0]-n/2,s[1]+n/2]]},getCellSize:()=>t,type:"grid"}},n=function(t){function e(t){const e={NEIGHBORS_DI:[0,1,1,0,-1,-1],NEIGHBORS_DJ:[[-1,-1,0,1,0,-1],[-1,0,1,1,1,0]],NUM_NEIGHBORS:6};e.RADIUS=Math.trunc(1.3*t/2),e.WIDTH=2*e.RADIUS,e.HEIGHT=Math.trunc(e.RADIUS*Math.sqrt(3)),e.SIDE=3*e.RADIUS/2;let o=[e.RADIUS/2,e.SIDE,e.WIDTH,e.SIDE,e.RADIUS/2,0];e.CORNERS_DX=o;let i=[0,0,e.HEIGHT/2,e.HEIGHT,e.HEIGHT,e.HEIGHT/2];return e.CORNERS_DY=i,e}const o=e(t);let i,n;return{getColRow:(t,e)=>{let i=Math.floor(t/o.SIDE),n=t-o.SIDE*i,s=e-i%2*o.HEIGHT/2,r=Math.floor(s/o.HEIGHT),a=s-o.HEIGHT*r;return n>Math.abs(o.RADIUS/2-o.RADIUS*a/o.HEIGHT)?[i,r]:[i-1,r+i%2-(a<o.HEIGHT/2?1:0)]},getXYCentre:(t,e)=>{let i=[t*o.SIDE,o.HEIGHT*(2*e+t%2)/2];return[i[0]+o.RADIUS,i[1]+o.HEIGHT/2]},getXYCentreCellUnits:(t,e)=>{const o=Math.sqrt(3);let i=[1.5*t,o*(2*e+t%2)/2];return[i[0]+1,i[1]+o/2]},getBoundary:(s,r,a)=>{let l=[];a||(a=0),a>0&&a!=i&&(i=a,n=e(t-2*a));const h=a?n:o;let c=[s*o.SIDE,o.HEIGHT*(2*r+s%2)/2];for(let t=0;t<h.NUM_NEIGHBORS;t++)l.push([Math.round(c[0]+2*a/3*2+h.CORNERS_DX[t]),Math.round(c[1]+2*a/3*2+h.CORNERS_DY[t])]);return l},getCellSize:()=>t,type:"hex"}},s=function(t){const e=t.data,o=t.width,i=t.height,n=t.cellSize,s=t.getLocationFn,r=t.coordToScreenFn,a=t.screenToCoordFn,l=t.preAggrFn,h=t.aggrFn,c=t.postAggrFn,g=t.offSetCoordRef,p=t.discretisationMode,d=t.reduceMaup,u=t.panel,f=t.discretiser,y=t.global,F=t.offSetMaupMode;let m=[];"relativeToMouse"==p?(m.xOffset=Math.trunc(r(g)[0]%n),m.yOffset=Math.trunc(r(g)[1]%n)):(m.xOffset=0,m.yOffset=0),m.type=f.type,m.cellSize=n,a([0,i]),a([o,0]),l&&l(m.flat(),n,y,u);for(let t of e){const e=[],o=s(t);if(o.type){const t=turf.bbox(o),i=r([t[0],t[1]]),s=r([t[2],t[3]]);for(let t=Math.trunc(i[0]/n);t<s[0]/n;t++)for(let o=Math.trunc(i[1]/n);o<s[1]/n;o++)e.push([t,o]);if(0==e.length){const t=turf.centroid(o);e.push([Math.trunc(t[0]/n),Math.trunc(t[1]/n)])}}else{const t=r(o);if(d){console.log("mauping");const o=f.getColRow(t[0]-m.xOffset,t[1]-m.yOffset),i=t[0]-m.xOffset-o[0]*n,s=t[1]-m.yOffset-o[1]*n;let r=i/n;r<.5?r=-(.5-r):r-=.5;let a=s/n;a<.5?a=-(.5-a):a-=.5,e.push([o[0],o[1],1-(Math.abs(r)+Math.abs(a))/2]),e.push([o[0]+(r<0?-1:1),o[1]+(a<0?-1:1),(Math.abs(r)+Math.abs(a))/2]),e.push([o[0]+(r<0?-1:1),o[1],Math.abs(r)]),e.push([o[0],o[1]+(a<0?-1:1),Math.abs(a)])}else{if(F)for(let o=0;o<n;o+=3)for(let i=0;i<n;i+=3)e.push([...f.getColRow(t[0]+(o-n/2)-m.xOffset,t[1]+(o-n/2)-m.yOffset),i*n+o]);e.push(f.getColRow(t[0]-m.xOffset,t[1]-m.yOffset))}}for(const o of e){if(m[o[0]]||(m[o[0]]=[]),!m[o[0]][o[1]]){const t=o[0],e=o[1];m[t][e]={col:t,row:e,getBoundary:o=>f.getBoundary(t,e,o),getXCentre:()=>f.getXYCentre(t,e)[0]+m.xOffset,getYCentre:()=>f.getXYCentre(t,e)[1]+m.yOffset,getCellSize:()=>n}}if(h)if(Array.isArray(h))for(const e of h)e&&e(m[o[0]][o[1]],t,o[2]?o[2]:1,y,u);else F?h(m[o[0]][o[1]],{...t,maupMode:o[2]},1,y,u):h(m[o[0]][o[1]],t,o[2]?o[2]:1,y,u)}}return c&&c(m.flat(),n,y,u),m};function r(t){const e=t.grid,o=t.properties,i=t.propertyTypes;if(void 0===o||void 0===i)return void console.log("Need to define properties and propertyTypes for smoothing");const n=t.discretiser,s=t.kernelRadius,r=e.length+s,a=Math.max(...Object.values(e.map((t=>t.length))))+s;{const t=[];for(let o=-s;o<s;o++)for(let i=-s;i<s;i++){let r;if("grid"==e.type)r=Math.sqrt(Math.pow(o,2)+Math.pow(i,2));else if("hex"==e.type){const[t,e]=n.getXYCentreCellUnits(0,0),[s,a]=n.getXYCentreCellUnits(o,o<0?i:-i);r=Math.sqrt(Math.pow(t-s,2)+Math.pow(e-a,2))}if(r<s){var l=(s-r)/(s+r);t[o]||(t[o]=[]),t[o][i]=l}}for(let l=0;l<o.length;l++)for(let g=0;g<r;g++)for(let p=0;p<a;p++){let d,u=0;for(var h=-s;h<=s;h++)for(var c=-s;c<=s;c++)if(g+h>=0&&g+h<r&&p+c>=0&&p+c<a)if("value"===i[l]){let i,n=e[g+h]&&e[g+h][p+c]?e[g+h][p+c][o[l]]:0;isNaN(n)&&(n=0),i="hex"!=e.type||g%2!=0||h%2!=1&&h%2!=-1?t[h]?t[h][c]:0:t[h]?t[h][c+1]:0,i>0&&(d=d?d+n*i:n*i,u=u?u+i:i)}else if("array"===i[l]){let i,n=e[g+h]&&e[g+h][p+c]&&e[g+h][p+c][o[l]]?e[g+h][p+c][o[l]]:[];if(i="hex"!=e.type||g%2!=0||h%2!=1&&h%2!=-1?t[h]?t[h][c]:0:t[h]?t[h][c+1]:0,i>0){u=u?u+i:i;for(let t=0;t<n.length;t++){let e=n[t];e||(e=0),isNaN(e)&&(e=0),d||(d=[]),d[t]=void 0!==d[t]&&d[t]?d[t]+e*i:e*i}}}e[g]||(e[g]=[]);for(let t=0;t<o.length;t++)if("value"===i[t])d/u>0&&(e[g][p]||(e[g][p]={getBoundary:()=>n.getBoundary(g,p),getXCentre:()=>n.getXYCentre(g,p)[0]+e.xOffset,getYCentre:()=>n.getXYCentre(g,p)[1]+e.yOffset,getCellSize:()=>n.getCellSize(),new:!0}),e[g][p]["_"+o[t]]=d/u);else if("array"===i[t]&&d)for(let i=0;i<d.length;i++)d[i]/u>0&&(e[g][p]||(e[g][p]={getBoundary:()=>n.getBoundary(g,p),getXCentre:()=>n.getXYCentre(g,p)[0]+e.xOffset,getYCentre:()=>n.getXYCentre(g,p)[1]+e.yOffset,getCellSize:()=>n.getCellSize(),new:!0}),e[g][p]["_"+o[t]]||(e[g][p]["_"+o[t]]=[]),e[g][p]["_"+o[t]][i]=d[i]/u)}for(let t of e.flat())for(let e=0;e<o.length;e++)void 0!==t["_"+o[e]]&&(t[o[e]]=t["_"+o[e]])}}function a(t){const o=t.grid,i=t.discretiser,n=t.properties,s=t.propertyTypes;if(void 0===n||void 0===s)return void console.log("Need to define properties and propertyTypes for smoothing");const r=t.kernelRadius,a=o.length+r,l=Math.max(...Object.values(o.map((t=>t.length))))+r;for(let t=0;t<n.length;t++)if("value"===s[t]){const s=[];for(let e=0;e<l;e++)for(let i=0;i<a;i++)s.push(o[i]&&o[i][e]&&o[i][e][n[t]]?o[i][e][n[t]]:0);e.blur2({data:s,width:a,height:l},r);for(let e=0;e<a;e++)for(let r=0;r<l;r++){const l=s[e+r*a];l>0?(o[e]||(o[e]=[]),o[e][r]||(o[e][r]={getBoundary:()=>i.getBoundary(e,r),getXCentre:()=>i.getXYCentre(e,r)[0]+o.xOffset,getYCentre:()=>i.getXYCentre(e,r)[1]+o.yOffset,getCellSize:()=>i.getCellSize(),new:!0}),o[e][r][n[t]]=l):o[e]&&o[e][r]&&o[e][r][n[t]]&&(o[e][r][n[t]]=l)}}return o}const l=o.extend({initialize:function(t){o.prototype.initialize.call(this,t),this.options.cellSize=this.options.cellSize?this.options.cellSize:5,this.options.discretisationShape=this.options.discretisationShape?this.options.discretisationShape:"grid",this.options.getLocationFn=this.options.getLocationFn?this.options.getLocationFn:t=>[t.lon,t.lat],this.options.discretiserFn=this.options.discretiserFn?this.options.discretiserFn:s,this.global={},this.grid=[],this._setupAggregationFunctions()},onAdd:function(t){o.prototype.onAdd.call(this,t),this.options.glyph?.initFn&&this.options.glyph.initFn([],this.options.cellSize,this.global,this),this.needRedraw()},_setupAggregationFunctions:function(){const{type:t,colourFieldFn:e,glyph:o}=this.options;o?(this.options.aggrFn=o.aggrFn,this.options.postAggrFn=o.postAggrFn,this.options.preAggrFn=o.preAggrFn,this.options.preDrawFn=o.preDrawFn,this.options.drawFn=o.drawFn,this.options.postDrawFn=o.postDrawFn,this.options.initFn=o.initFn,this.options.tooltipTextFn=o.tooltipTextFn):"count"===t?this.options.aggrFn=(t,e,o)=>t.value=(t.value??0)+o:"sum"===t?this.options.aggrFn=(t,o,i)=>t.value=(t.value??0)+e(o)*i:"mean"===t&&(this.options.aggrFn=(t,o,i)=>{t.sum=(t.sum??0)+e(o)*i,t.count=(t.count??0)+1},this.options.postAggrFn=t=>{for(const e of t.flat())e&&e.count>0&&(e.value=e.sum/e.count)})},onDrawLayer:function(e){const o=e.canvas.getContext("2d");o.clearRect(0,0,e.canvas.width,e.canvas.height);let{cellSize:s,discretisationShape:l,kernelBW:h,reduceMaup:c,data:g}=this.options;this.discretiser&&this._previousCellSize===s||("grid"===l?this.discretiser=i(s):"hex"===l&&(this.discretiser=n(s))),this.global.discretiser=this.discretiser,this.options.glyph?.initFn&&this.options.glyph.initFn([],s,this.global,this);const p=o=>{const i=t.latLng(o[1],o[0]),n=this._map.latLngToContainerPoint(i),s=[n.x,n.y],r=100;return(s[0]<-100||s[0]>e.size.x+r||s[1]<-100||s[1]>e.size.y+r)&&Math.random()<.01&&console.warn(`[coordToScreenFn] Coordinate [${s[0]}, ${s[1]}] is far outside canvas bounds [0, 0, ${e.size.x}, ${e.size.y}]`),s};this.grid=this.options.discretiserFn({data:g,width:e.size.x,height:e.size.y,getLocationFn:this.options.getLocationFn,coordToScreenFn:p,screenToCoordFn:e=>{const o=t.point(e[0],e[1]),i=this._map.containerPointToLatLng(o);return[i.lng,i.lat]},cellSize:s,discretiser:this.discretiser,aggrFn:this.options.aggrFn,postAggrFn:this.options.postAggrFn,global:this.global,panel:this});const d=this.grid.flat().filter((t=>t));if((!this._hasLoggedGrid||0===d.length)&&(console.log(`[Glyph Layer] Grid: ${this.grid.length}x${this.grid[0]?this.grid[0].length:0}, ${d.length} populated cells`),this._hasLoggedGrid=!0,0===d.length&&g.length>0)){const e=g[0],o=this.options.getLocationFn(e),i=p(o),n=this._map.getBounds().contains(t.latLng(o[1],o[0]));console.warn(`[Glyph Layer] No cells populated. Sample: ${o} -> ${i}, within bounds: ${n}`)}if(this._previousCellSize=s,h&&h>0){(this.options.useBlur?a:r)({grid:this.grid,properties:this.options.glyph?.kernelSmoothProperties,propertyTypes:this.options.glyph?.kernelSmoothPropertyTypes,discretiser:this.discretiser,kernelRadius:this.options.useBlur?Math.trunc(h/2):h})}if(this.options.glyph?.preDrawFn&&(o.save(),this.options.glyph.preDrawFn(this.grid.flat(),s,o,this.global,this),o.restore()),this.options.glyph?.drawFn){o.save();const t=Array.isArray(this.options.glyph.drawFn)?this.options.glyph.drawFn:[this.options.glyph.drawFn];for(const e of t)for(const t of this.grid.flat())t&&e(t,t.getXCentre(),t.getYCentre(),s,o,this.global,this);o.restore()}this.options.glyph?.postDrawFn&&(o.save(),this.options.glyph.postDrawFn(this.grid.flat(),s,o,this.global,this),o.restore())},setData:function(t){this.options.data=t,this.needRedraw()},setOptions:function(e){t.Util.setOptions(this,e),this._setupAggregationFunctions(),this.needRedraw()}}),h=t.GridLayer.extend({initialize:function(e){const o={tileSize:256,minZoom:1,maxZoom:18,updateWhenZooming:!1,keepBuffer:2,...e};t.GridLayer.prototype.initialize.call(this,o),this.options.cellSize=this.options.cellSize||5,this.options.discretisationShape=this.options.discretisationShape||"grid",this.options.getLocationFn=this.options.getLocationFn||(t=>[t.lon,t.lat]),this.options.discretiserFn=this.options.discretiserFn||s,this.global={},this._dataIndex=null,this._previousCellSize=null,this._setupAggregationFunctions(),this._setupDiscretiser()},_setupAggregationFunctions:function(){const{type:t,colourFieldFn:e,glyph:o}=this.options;o?(this.options.aggrFn=o.aggrFn,this.options.postAggrFn=o.postAggrFn,this.options.preAggrFn=o.preAggrFn,this.options.preDrawFn=o.preDrawFn,this.options.drawFn=o.drawFn,this.options.postDrawFn=o.postDrawFn,this.options.initFn=o.initFn,this.options.tooltipTextFn=o.tooltipTextFn):"count"===t?this.options.aggrFn=(t,e,o)=>t.value=(t.value??0)+o:"sum"===t?this.options.aggrFn=(t,o,i)=>t.value=(t.value??0)+e(o)*i:"mean"===t&&(this.options.aggrFn=(t,o,i)=>{t.sum=(t.sum??0)+e(o)*i,t.count=(t.count??0)+1},this.options.postAggrFn=t=>{for(const e of t.flat())e&&e.count>0&&(e.value=e.sum/e.count)})},_setupDiscretiser:function(){const{cellSize:t,discretisationShape:e}=this.options;this.discretiser&&this._previousCellSize===t||("grid"===e?this.discretiser=i(t):"hex"===e&&(this.discretiser=n(t)),this._previousCellSize=t),this.global.discretiser=this.discretiser},onAdd:function(e){t.GridLayer.prototype.onAdd.call(this,e),this._buildDataIndex(),this.options.glyph?.initFn&&this.options.glyph.initFn([],this.options.cellSize,this.global,this)},createTile:function(e){console.log(`[TiledGlyph] Creating tile ${e.z}:${e.x}:${e.y} (SYNCHRONOUS)`);const o=t.DomUtil.create("canvas","leaflet-tile"),i=this.getTileSize();o.width=i.x,o.height=i.y;const n=o.getContext("2d"),s=this._tileCoordsToBounds(e),r=this._createTileTransforms(e,s,i);return this._renderTileGlyphs(n,s,i,r,e),console.log(`[TiledGlyph] Tile ${e.z}:${e.x}:${e.y} rendering complete (SYNCHRONOUS)`),o},_createTileTransforms:function(e,o,i){return{coordToTilePixelFn:i=>{const n=t.latLng(i[1],i[0]),s=this._map.project(o.getNorthWest(),e.z),r=this._map.project(n,e.z),a=r.x-s.x,l=r.y-s.y;return(Math.abs(a)>1e4||Math.abs(l)>1e4)&&console.warn(`[TileTransform] Very large coordinate: ${i} -> [${a}, ${l}]`),[a,l]},tilePixelToCoordFn:i=>{const n=this._map.project(o.getNorthWest(),e.z),s=t.point(n.x+i[0],n.y+i[1]),r=this._map.unproject(s,e.z);return[r.lng,r.lat]}}},_renderTileGlyphs:function(t,e,o,i,n){const s=this._getDataForTile(e);if(console.log(`[TiledGlyph] Rendering tile ${n.z}:${n.x}:${n.y}, found ${s?.length||0} data points`),console.log("[TiledGlyph] Tile bounds:",e.toBBoxString()),!s||0===s.length)return void console.log(`[TiledGlyph] No data in tile ${n.z}:${n.x}:${n.y}, skipping`);if(s.length>0){const t=s[0],e=this.options.getLocationFn(t),n=i.coordToTilePixelFn(e);if(console.log(`[TiledGlyph] BEFORE GRID: Sample point ${e} -> tile coord ${n}`),console.log(`[TiledGlyph] Tile size: ${o.x}x${o.y}, cellSize: ${this.options.cellSize}`),isNaN(n[0])||isNaN(n[1]))return void console.error(`[TiledGlyph] NaN coordinates detected! Location: ${e}, tileCoord: ${n}`)}const l=this.options.discretiserFn({data:s,width:o.x,height:o.y,getLocationFn:this.options.getLocationFn,coordToScreenFn:i.coordToTilePixelFn,screenToCoordFn:i.tilePixelToCoordFn,cellSize:this.options.cellSize,discretiser:this.discretiser,aggrFn:this.options.aggrFn,postAggrFn:this.options.postAggrFn,global:this.global,panel:this});if(console.log(`[TiledGlyph] Generated grid for tile ${n.z}:${n.x}:${n.y}:`,l?.length||0,"rows"),l&&l.length>0){const t=l.flat().filter((t=>t));if(console.log(`[TiledGlyph] Found ${t.length} populated cells`),s.length>0){const t=s[0],e=this.options.getLocationFn(t),o=i.coordToTilePixelFn(e);console.log(`[TiledGlyph] Sample transformation: ${e} -> ${o}`)}}if(this.options.kernelBW&&this.options.kernelBW>0){(this.options.useBlur?a:r)({grid:l,properties:this.options.glyph?.kernelSmoothProperties,propertyTypes:this.options.glyph?.kernelSmoothPropertyTypes,discretiser:this.discretiser,kernelRadius:this.options.useBlur?Math.trunc(this.options.kernelBW/2):this.options.kernelBW})}this._drawGlyphsOnTile(t,l,n)},_drawGlyphsOnTile:function(t,e,o){const{cellSize:i}=this.options;console.log(`[TiledGlyph] Drawing glyphs on tile ${o.z}:${o.x}:${o.y} (${e?.length||0} cols, canvas: ${t.canvas.width}x${t.canvas.height})`);const n=t=>{const e=[];for(let o=0;o<t.length;o++)if(t[o])for(let i=0;i<t[o].length;i++)t[o][i]&&e.push(t[o][i]);return e};if(this.options.glyph?.preDrawFn&&(t.save(),this.options.glyph.preDrawFn(n(e),i,t,this.global,this),t.restore()),this.options.glyph?.drawFn){t.save();const n=Array.isArray(this.options.glyph.drawFn)?this.options.glyph.drawFn:[this.options.glyph.drawFn];let s=0,r=1/0,a=-1/0,l=1/0,h=-1/0;for(const o of n)for(let n=0;n<e.length;n++)if(e[n])for(let c=0;c<e[n].length;c++){const g=e[n][c];if(!g)continue;const p=g.getXCentre(),d=g.getYCentre();r=Math.min(r,p),a=Math.max(a,p),l=Math.min(l,d),h=Math.max(h,d),0===s&&console.log(`[TiledGlyph] Drawing cell at (${p}, ${d}) with data:`,g.records?.length||0,"records"),o(g,p,d,i,t,this.global,this),s++}console.log(`[TiledGlyph] Drew ${s} cells on tile ${o.z}:${o.x}:${o.y}, coord range: x[${r.toFixed(1)}, ${a.toFixed(1)}], y[${l.toFixed(1)}, ${h.toFixed(1)}]`),t.restore()}else console.warn(`[TiledGlyph] No drawFn provided for tile ${o.z}:${o.x}:${o.y}`);this.options.glyph?.postDrawFn&&(t.save(),this.options.glyph.postDrawFn(n(e),i,t,this.global,this),t.restore())},_buildDataIndex:function(){if(!this.options.data)return void(this._dataIndex=new Map);if(!this._map)return console.log("[TiledGriddedGlyph] Map not available yet, will use simple bounds checking"),void(this._dataIndex=null);console.log(`[TiledGriddedGlyph] Building spatial index for ${this.options.data.length} data points...`),this._dataIndex=new Map;const e=Math.min(10,this.options.maxZoom);for(const o of this.options.data){const i=this.options.getLocationFn(o);if(!i||i.length<2)continue;const n=t.latLng(i[1],i[0]),s=this._map.project(n,e).divideBy(this.getTileSize().x).floor(),r=`${e}:${s.x}:${s.y}`;this._dataIndex.has(r)||this._dataIndex.set(r,[]),this._dataIndex.get(r).push(o)}console.log(`[TiledGriddedGlyph] Spatial index built with ${this._dataIndex.size} tile buckets`)},_getDataForTile:function(e){if(!this.options.data)return[];const o=[],i=.5*(e.getNorth()-e.getSouth()),n=.5*(e.getEast()-e.getWest()),s=t.latLngBounds([e.getSouth()-i,e.getWest()-n],[e.getNorth()+i,e.getEast()+n]);if(this.options.data.length>0&&!this._loggedDataBounds){const t=this.options.data.map((t=>this.options.getLocationFn(t)[1])),o=this.options.data.map((t=>this.options.getLocationFn(t)[0])),i={minLat:Math.min(...t),maxLat:Math.max(...t),minLng:Math.min(...o),maxLng:Math.max(...o)};console.log(`[TiledGlyph] Data bounds: lat[${i.minLat}, ${i.maxLat}], lng[${i.minLng}, ${i.maxLng}]`),console.log(`[TiledGlyph] Tile bounds: ${e.toBBoxString()}`),console.log(`[TiledGlyph] Buffered bounds: ${s.toBBoxString()}`),this._loggedDataBounds=!0}let r=0,a=0;for(const e of this.options.data){const i=this.options.getLocationFn(e);if(!i||i.length<2)continue;r++;const n=t.latLng(i[1],i[0]);s.contains(n)&&(o.push(e),a++)}if(0===o.length&&r>0){console.log(`[TiledGlyph] Checked ${r} points, ${a} within buffered bounds for tile`);const t=Math.min(3,this.options.data.length);for(let e=0;e<t;e++){const t=this.options.getLocationFn(this.options.data[e]);console.log(`[TiledGlyph] Sample point ${e}: [${t[0]}, ${t[1]}]`)}}return o},setData:function(t){this.options.data=t,this._buildDataIndex(),this.redraw()},setOptions:function(e){t.Util.setOptions(this,e),this._setupAggregationFunctions(),this._setupDiscretiser(),e.data&&this._buildDataIndex(),this.redraw()},_tileReady:function(e,o,i){o&&console.warn(`[TiledGriddedGlyph] Tile error at ${e.z}:${e.x}:${e.y}`,o),t.GridLayer.prototype._tileReady.call(this,e,o,i)}}),c=function(t){const o=t.numBins,i=t.context,n=t.minV,s=t.maxV,r=t.values,a=t.x,l=t.y,h=t.width,c=t.height,g=t.colourScale,p=Array(o+2).fill(0),d=(s-n)/p.length;for(const t of r)if(t){const e=Math.trunc((t-n)/d)+1;e<1?p[0]++:e>p.length-2?p[p.length-1]++:p[e]++}const u=Math.max(...p.slice(1,-2)),f=e.scaleLinear().domain([0,u]).range([0,c-30]),y=h/p.length;i.fillStyle="#fff8",i.fillRect(a,l,h,c);for(let t=0;t<p.length;t++)i.fillStyle=g(t/p.length),i.fillRect(a+t*y,l+c-10,y,-10),0==t?i.fillStyle=g(0):t==p.length-1?i.fillStyle=g(1):i.fillStyle=g(.5),i.fillRect(a+t*y,l+c-20,y,-Math.min(f(p[t]),c-20));i.fillStyle="#000",i.font="sans-serif 8pt",i.textBaseline="bottom",i.textAlign="left",i.fillText(n.toLocaleString(void 0,{minimumFractionDigits:0,maximumFractionDigits:3}),a+y,l+c),i.textAlign="right",i.fillText(s.toLocaleString(void 0,{minimumFractionDigits:0,maximumFractionDigits:3}),a+h-y,l+c)},g=t=>{const e=t.name,o=t.decKey,i=t.incKey,n=t.resetKey;t.incDecType;const s=t.decFn?t.decFn:t=>t-1,r=t.incFn?t.incFn:t=>t+1,a=t.numberFormatFn?t.numberFormatFn:t=>+t.toFixed(),l=t.resetFn,h=t.resetType?t.resetType:"preDraw";let c=void 0!==t.autoscale&&t.autoscale;const g=t.onChangeFn,p=(t,o)=>{null!=t[e]&&(t[e]=r(t[e])),g&&g(t),o.redraw()},d=(t,o)=>{null!=t[e]&&(t[e]=s(t[e])),g&&g(t),o.redraw()},u=(t,o)=>{t[e]=void 0,g&&g(t),o.redraw()},f=()=>c;return{...t,initFn:(t,e,s,r)=>{r.addEventListener("keydown",(t=>{(o&&o.startsWith("SHIFT_")===t.shiftKey&&(o.endsWith("LEFT")&&37==t.keyCode||o.endsWith("RIGHT")&&39==t.keyCode)||t.key===o)&&(t.preventDefault(),d(s,r)),(i&&i.startsWith("SHIFT_")===t.shiftKey&&(i.endsWith("LEFT")&&37==t.keyCode||i.endsWith("RIGHT")&&39==t.keyCode)||t.key===i)&&(t.preventDefault(),p(s,r)),n&&t.key==n&&(t.preventDefault(),u(s,r))}))},toggleAutoscale:()=>{c=!c},getAutoscale:f,preAggrFn:"preAggr"==h?(t,o,i,n,s)=>{l&&(f()||void 0===n[e])&&(n[e]=l(t.flat(),o,s))}:void 0,preDrawFn:"preDraw"==h?(t,o,i,n,s)=>{l&&(f()||void 0===n[e])&&(n[e]=l(t.flat(),o,s))}:void 0,doInc:p,doDec:d,doReset:u,numberFormatFn:a}};function p(t,e,o,i){const n=e.getBoundary(i);t.fillStyle=o,t.beginPath(),t.moveTo(n[0][0],n[0][1]);for(let e=1;e<n.length;e++)t.lineTo(n[e][0],n[e][1]);t.closePath(),t.fill()}const d=t=>{t||(t={});const o=t.colourScheme?t.colourScheme:e.scaleSequential(e.interpolateOranges),i=void 0===t.colourAutoscale||t.colourAutoscale,n=t.valueFn,s=t.normaliseValueFn,r=t.weightValueFn,a=t.type,l=void 0===t.useTransparency||t.useTransparency,h=void 0===t.showLegend||t.showLegend,p=t.numberFormatFn,d=t.initFn,u=t.preDrawFn,f=t.postDrawFn,y=t.aggrFn,F=t.postAggrFn,m=t.tooltipTextFn;return{scaleParams:[g({name:"colourMaxV",decKey:"LEFT",decFn:t=>t-t/10,incKey:"RIGHT",incFn:t=>t+t/10,resetKey:"s",autoscale:i,resetFn:(t,o,i)=>e.quantile(t.map((t=>t&&t.value?t.value:0)),.99)})],initFn:(t,e,o,i)=>{d&&d(t,e,o,i)},kernelSmoothProperties:["value"],kernelSmoothPropertyTypes:["value"],preAggrFn:t=>{},aggrFn:(t,e,o,i,l)=>{let h;if("count"!=a&&(h=n(e,i)??0*o??0),"mean"==a)t.value=t.value?t.value+(h||0):h,t.count=t.count?t.count+o:o;else if("sum"==a)t.value=t.value?t.value+(h||0):h,t.count=t.count?t.count+o:o;else if("weightedMean"==a){const i=r(e)*o??0;t.value=t.value?t.value+h*i:h*i,t.totalWeight=t.totalWeight?t.totalWeight+i:i}else"count"==a&&(t.value=t.count?t.count+o:o,t.count=t.value);if(t.count=t.count?t.count+o:o,s){const o=s(e)??0;t.denominator=t.denominator?t.denominator+o:o}y&&y(t,e,o,i,l)},postAggrFn:(t,e,o,i)=>{if("mean"==a)for(const e of t)e&&e.count&&(e.value=e.value/e.count);if("weightedMean"==a)for(const e of t)e&&e.count&&(e.value=e.value/e.totalWeight);if(s)for(const e of t)e.value=e.value/e.denominator??0;F&&F(t,e,o,i)},preDrawFn:(t,o,i,n,s)=>{u&&u(t,o,i,n,s),n.colourScale=e.scaleLinear().domain([0,n.colourMaxV]).range([0,1]).clamp(!0)},drawFn:(t,e,i,n,s,r,a)=>{if(t&&t.value){const e=t.getBoundary();s.fillStyle=o(r.colourScale(t.value)),l&&(s.globalAlpha=r.colourScale(t.value)),s.beginPath(),s.moveTo(e[0][0],e[0][1]);for(let t=1;t<e.length;t++)s.lineTo(e[t][0],e[t][1]);s.closePath(),s.fill()}},postDrawFn:(t,e,i,n,s)=>{h&&n.colourMaxV&&(c({context:i,values:t.map((t=>t?t.value:NaN)),minV:0,maxV:n.colourMaxV,numBins:20,x:s.getWidth()-160,y:s.getHeight()-60,width:150,height:50,colourScale:o}),f&&f(t,e,i,n,s))},tooltipTextFn:t=>m?m(t):void 0!==t.value?p?p(t.value):t.value:""}},u=function(t){const e=t&&t.valueFn?t.valueFn:void 0,o=t&&t.glyphLocationFn?t.glyphLocationFn:void 0,n=t&&t.boundaryFn?t.boundaryFn:void 0;return function(t){const s=t.data,r=t.width,a=t.height,l=t.cellSize,h=t.getLocationFn,c=t.coordToScreenFn,g=t.screenToCoordFn,p=t.preAggrFn,d=t.aggrFn,u=t.postAggrFn,f=t.panel,y=i(l),F=t.global;let m={};const v=g([0,a]),T=g([r,0]);p&&p([],l,F,f);let S=0;for(let t of s){let i;e?i=e(t):(i=S,S++);const s=o?o(i)??[0,0]:h(t),r=c(s);if(s[0]>=v[0]&&s[0]<=T[0]&&s[1]>=v[1]&&s[1]<=T[1]){let e=m[i];if(!e){let t;n&&(t=n(i)?.map((t=>c([t[0],t[1]])))),e={getBoundary:t?()=>t:t=>y.getBoundaryScreenCoord(r[0],r[1],t),getXCentre:()=>Math.trunc(r[0]),getYCentre:()=>Math.trunc(r[1]),getCellSize:()=>l},m[i]=e}if(d)if(Array.isArray(d))for(const o of d)o&&o(e,t,1,F,f);else d(e,t,1,F,f)}}const _=Object.values(m);return _.yOffset=0,_.xOffset=0,u&&u(_,l,F,f),_}};export{l as GriddedGlyphLayer,h as TiledGriddedGlyphLayer,a as _blur,p as _drawCellBackground,c as _drawLegend,s as _generate2DHeatMap,i as _getGridDiscretiser,n as _getHexDiscretiser,r as _kernelSmooth,g as _setupParamFns,u as createDiscretiserValue,d as heatmapGlyph};
